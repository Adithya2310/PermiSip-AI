{
  "language": "Solidity",
  "sources": {
    "contracts/PermiSIPAI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Contract Address: 0x82adEeeFE3f79D0d459878F36B44CD178080013d\npragma solidity ^0.8.20;\n\n/**\n * @title IERC20\n * @notice Minimal ERC20 interface for token transfers\n */\ninterface IERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n\n/**\n * @title PermiSIPAI\n * @notice Main contract for PermiSIP AI DeFAI automation using MetaMask Advanced Permissions\n * @dev Uses ERC-7715 permissions for automated USDC investments\n *      SIP investments use USDC, Agent payments use ETH\n */\ncontract PermiSIPAI {\n    struct Strategy {\n        uint8 aavePercent;\n        uint8 compoundPercent;\n        uint8 uniswapPercent;\n    }\n\n    struct SIPPlan {\n        address user;\n        uint256 planId;           // Database plan ID for reference\n        uint256 monthlyAmount;    // Amount in USDC (6 decimals) or ETH\n        Strategy strategy;\n        uint256 totalDeposited;\n        uint256 lastDepositTime;\n        uint256 createdAt;\n        bool active;\n        bool rebalancingEnabled;  // Whether AI rebalancing is enabled\n    }\n\n    // User address => Plan ID => SIPPlan (users can have multiple plans)\n    mapping(address => mapping(uint256 => SIPPlan)) public userPlans;\n    // User address => array of plan IDs\n    mapping(address => uint256[]) public userPlanIds;\n    // Legacy: User address => single plan (for backward compatibility)\n    mapping(address => SIPPlan) public legacyUserPlans;\n    \n    address public aave;\n    address public compound;\n    address public uniswap;\n    address public owner;\n    \n    // USDC token address on Sepolia\n    address public constant USDC = 0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238;\n    \n    // Native ETH address constant (ERC-7528)\n    address public constant NATIVE_ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    \n    // Expert agent address for AI payments\n    address public expertAgentAddress;\n\n    event SIPCreated(address indexed user, uint256 indexed planId, uint256 monthlyAmount);\n    event DepositExecuted(address indexed user, uint256 indexed planId, uint256 amount);\n    event FundsAllocated(address indexed protocol, uint256 amount);\n    event PlanCancelled(address indexed user, uint256 indexed planId);\n    event PlanPaused(address indexed user, uint256 indexed planId);\n    event PlanResumed(address indexed user, uint256 indexed planId);\n    event PlanRebalanced(address indexed user, uint256 indexed planId, uint8 aavePercent, uint8 compoundPercent, uint8 uniswapPercent);\n    event AgentPaymentExecuted(address indexed user, address indexed agent, uint256 amount);\n    event ExpertAgentAddressUpdated(address indexed oldAddress, address indexed newAddress);\n    // Legacy events for backward compatibility\n    event LegacySIPCreated(address indexed user, uint256 totalAmount, uint256 duration);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n\n    constructor(address _aave, address _compound, address _uniswap) {\n        aave = _aave;\n        compound = _compound;\n        uniswap = _uniswap;\n        owner = msg.sender;\n    }\n\n    // ============================================\n    // NEW PLAN-ID BASED FUNCTIONS (Multi-plan support)\n    // ============================================\n\n    /**\n     * @notice Create a new SIP plan for a user with plan ID and rebalancing option\n     * @param planId The database plan ID for reference\n     * @param monthlyAmount Monthly investment amount\n     * @param aavePercent Percentage allocation to Aave\n     * @param compoundPercent Percentage allocation to Compound\n     * @param uniswapPercent Percentage allocation to Uniswap\n     * @param enableRebalancing Whether to enable AI rebalancing\n     */\n    function createSIPPlanWithId(\n        uint256 planId,\n        uint256 monthlyAmount,\n        uint8 aavePercent,\n        uint8 compoundPercent,\n        uint8 uniswapPercent,\n        bool enableRebalancing\n    ) external {\n        require(monthlyAmount > 0, \"Monthly amount must be greater than 0\");\n        require(aavePercent + compoundPercent + uniswapPercent == 100, \"Percents must sum to 100\");\n        require(userPlans[msg.sender][planId].createdAt == 0, \"Plan already exists\");\n\n        Strategy memory strategy = Strategy({\n            aavePercent: aavePercent,\n            compoundPercent: compoundPercent,\n            uniswapPercent: uniswapPercent\n        });\n\n        userPlans[msg.sender][planId] = SIPPlan({\n            user: msg.sender,\n            planId: planId,\n            monthlyAmount: monthlyAmount,\n            strategy: strategy,\n            totalDeposited: 0,\n            lastDepositTime: 0,\n            createdAt: block.timestamp,\n            active: true,\n            rebalancingEnabled: enableRebalancing\n        });\n\n        userPlanIds[msg.sender].push(planId);\n\n        emit SIPCreated(msg.sender, planId, monthlyAmount);\n    }\n\n    /**\n     * @notice Execute a deposit for a specific plan (user must call directly)\n     * @param planId The plan ID to execute deposit for\n     */\n    function depositToPlan(uint256 planId) external payable {\n        SIPPlan storage plan = userPlans[msg.sender][planId];\n        require(plan.active, \"No active plan\");\n        require(plan.user == msg.sender, \"Not plan owner\");\n        require(msg.value > 0, \"Must send ETH\");\n\n        _allocateFundsETH(plan, msg.value);\n\n        plan.totalDeposited += msg.value;\n        plan.lastDepositTime = block.timestamp;\n\n        emit DepositExecuted(msg.sender, planId, msg.value);\n    }\n\n    /**\n     * @notice Deposit ETH on behalf of a user's plan (only owner/server can call)\n     * @dev Used by the server after executing SIP via spend permissions\n     * @param user The user whose plan to deposit to\n     * @param planId The plan ID to deposit to\n     */\n    function depositForUser(address user, uint256 planId) external payable onlyOwner {\n        SIPPlan storage plan = userPlans[user][planId];\n        require(plan.createdAt > 0, \"Plan does not exist\");\n        require(plan.active, \"Plan not active\");\n        require(msg.value > 0, \"Must send ETH\");\n\n        _allocateFundsETH(plan, msg.value);\n\n        plan.totalDeposited += msg.value;\n        plan.lastDepositTime = block.timestamp;\n\n        emit DepositExecuted(user, planId, msg.value);\n    }\n\n    /**\n     * @notice Rebalance a user's SIP plan with new strategy allocation\n     * @dev Called by the owner (server) after AI generates new strategy\n     * @param user The user whose plan is being rebalanced\n     * @param planId The plan ID to rebalance\n     * @param newAavePercent New percentage allocation to Aave\n     * @param newCompoundPercent New percentage allocation to Compound\n     * @param newUniswapPercent New percentage allocation to Uniswap\n     */\n    function rebalance(\n        address user,\n        uint256 planId,\n        uint8 newAavePercent,\n        uint8 newCompoundPercent,\n        uint8 newUniswapPercent\n    ) external onlyOwner {\n        SIPPlan storage plan = userPlans[user][planId];\n        require(plan.active, \"No active plan\");\n        require(plan.user == user, \"User mismatch\");\n        require(plan.rebalancingEnabled, \"Rebalancing not enabled\");\n        require(newAavePercent + newCompoundPercent + newUniswapPercent == 100, \"Percents must sum to 100\");\n\n        plan.strategy.aavePercent = newAavePercent;\n        plan.strategy.compoundPercent = newCompoundPercent;\n        plan.strategy.uniswapPercent = newUniswapPercent;\n\n        emit PlanRebalanced(user, planId, newAavePercent, newCompoundPercent, newUniswapPercent);\n    }\n\n    /**\n     * @notice Toggle rebalancing for a plan\n     * @param planId The plan ID\n     * @param enabled Whether to enable rebalancing\n     */\n    function setRebalancing(uint256 planId, bool enabled) external {\n        SIPPlan storage plan = userPlans[msg.sender][planId];\n        require(plan.createdAt > 0, \"Plan does not exist\");\n        require(plan.user == msg.sender, \"Not plan owner\");\n        \n        plan.rebalancingEnabled = enabled;\n    }\n\n    /**\n     * @notice Cancel a specific plan\n     * @param planId The plan ID to cancel\n     */\n    function cancelPlanById(uint256 planId) external {\n        SIPPlan storage plan = userPlans[msg.sender][planId];\n        require(plan.active, \"No active plan\");\n        require(plan.user == msg.sender, \"Not plan owner\");\n\n        plan.active = false;\n        emit PlanCancelled(msg.sender, planId);\n    }\n\n    /**\n     * @notice Pause a specific plan\n     * @param planId The plan ID to pause\n     */\n    function pausePlanById(uint256 planId) external {\n        SIPPlan storage plan = userPlans[msg.sender][planId];\n        require(plan.active, \"No active plan\");\n        require(plan.user == msg.sender, \"Not plan owner\");\n        \n        plan.active = false;\n        emit PlanPaused(msg.sender, planId);\n    }\n\n    /**\n     * @notice Resume a paused plan\n     * @param planId The plan ID to resume\n     */\n    function resumePlanById(uint256 planId) external {\n        SIPPlan storage plan = userPlans[msg.sender][planId];\n        require(plan.createdAt > 0, \"Plan does not exist\");\n        require(plan.user == msg.sender, \"Not plan owner\");\n        require(!plan.active, \"Plan already active\");\n        \n        plan.active = true;\n        emit PlanResumed(msg.sender, planId);\n    }\n\n    /**\n     * @notice Get a user's SIP plan by ID\n     */\n    function getPlanById(address user, uint256 planId) external view returns (SIPPlan memory) {\n        return userPlans[user][planId];\n    }\n\n    /**\n     * @notice Get all plan IDs for a user\n     */\n    function getUserPlanIds(address user) external view returns (uint256[] memory) {\n        return userPlanIds[user];\n    }\n\n    // ============================================\n    // LEGACY FUNCTIONS (Backward compatibility)\n    // ============================================\n\n    /**\n     * @notice Create a SIP plan (legacy - single plan per user)\n     */\n    function createSIPPlan(\n        uint256 totalAmount,\n        uint256 monthlyAmount,\n        uint256 duration,\n        uint8 aavePercent,\n        uint8 compoundPercent,\n        uint8 uniswapPercent\n    ) external payable {\n        require(msg.value == totalAmount, \"Send correct ETH amount\");\n        require(monthlyAmount <= totalAmount, \"Monthly amount exceeds total\");\n        require(aavePercent + compoundPercent + uniswapPercent == 100, \"Percents must sum to 100\");\n        require(!legacyUserPlans[msg.sender].active, \"Plan already exists\");\n\n        Strategy memory strategy = Strategy({\n            aavePercent: aavePercent,\n            compoundPercent: compoundPercent,\n            uniswapPercent: uniswapPercent\n        });\n\n        legacyUserPlans[msg.sender] = SIPPlan({\n            user: msg.sender,\n            planId: 0,\n            monthlyAmount: monthlyAmount,\n            strategy: strategy,\n            totalDeposited: 0,\n            lastDepositTime: 0,\n            createdAt: block.timestamp,\n            active: true,\n            rebalancingEnabled: false\n        });\n\n        emit LegacySIPCreated(msg.sender, totalAmount, duration);\n\n        // Execute first deposit immediately\n        _executeDeposit(msg.sender, totalAmount);\n    }\n\n    function _executeDeposit(address user, uint256 amount) internal {\n        SIPPlan storage plan = legacyUserPlans[user];\n        require(plan.active, \"No active plan\");\n\n        _allocateFundsETH(plan, amount);\n\n        plan.totalDeposited += amount;\n        plan.lastDepositTime = block.timestamp;\n\n        emit DepositExecuted(user, 0, amount);\n    }\n\n    /**\n     * @notice Internal function to allocate ETH funds to protocols based on strategy\n     */\n    function _allocateFundsETH(SIPPlan storage plan, uint256 amount) internal {\n        // Calculate amounts for each protocol\n        uint256 aaveAmount = (amount * plan.strategy.aavePercent) / 100;\n        uint256 compoundAmount = (amount * plan.strategy.compoundPercent) / 100;\n        uint256 uniswapAmount = (amount * plan.strategy.uniswapPercent) / 100;\n\n        // Send to mock protocols\n        if (aaveAmount > 0) {\n            (bool success1, ) = aave.call{value: aaveAmount}(\"\");\n            require(success1, \"Aave deposit failed\");\n            emit FundsAllocated(aave, aaveAmount);\n        }\n\n        if (compoundAmount > 0) {\n            (bool success2, ) = compound.call{value: compoundAmount}(\"\");\n            require(success2, \"Compound deposit failed\");\n            emit FundsAllocated(compound, compoundAmount);\n        }\n\n        if (uniswapAmount > 0) {\n            (bool success3, ) = uniswap.call{value: uniswapAmount}(\"\");\n            require(success3, \"Uniswap deposit failed\");\n            emit FundsAllocated(uniswap, uniswapAmount);\n        }\n    }\n\n    /**\n     * @notice Internal function to allocate USDC funds to protocols based on strategy\n     */\n    function _allocateFundsUSDC(SIPPlan storage plan, uint256 amount) internal {\n        // Calculate amounts for each protocol\n        uint256 aaveAmount = (amount * plan.strategy.aavePercent) / 100;\n        uint256 compoundAmount = (amount * plan.strategy.compoundPercent) / 100;\n        uint256 uniswapAmount = (amount * plan.strategy.uniswapPercent) / 100;\n\n        IERC20 usdc = IERC20(USDC);\n\n        // Transfer USDC to protocols\n        if (aaveAmount > 0) {\n            require(usdc.transfer(aave, aaveAmount), \"Aave transfer failed\");\n            emit FundsAllocated(aave, aaveAmount);\n        }\n\n        if (compoundAmount > 0) {\n            require(usdc.transfer(compound, compoundAmount), \"Compound transfer failed\");\n            emit FundsAllocated(compound, compoundAmount);\n        }\n\n        if (uniswapAmount > 0) {\n            require(usdc.transfer(uniswap, uniswapAmount), \"Uniswap transfer failed\");\n            emit FundsAllocated(uniswap, uniswapAmount);\n        }\n    }\n\n    /**\n     * @notice Get a user's SIP plan (legacy)\n     */\n    function getPlan(address user) external view returns (SIPPlan memory) {\n        return legacyUserPlans[user];\n    }\n\n    /**\n     * @notice Cancel a SIP plan (legacy)\n     */\n    function cancelPlan() external {\n        SIPPlan storage plan = legacyUserPlans[msg.sender];\n        require(plan.active, \"No active plan\");\n\n        plan.active = false;\n        emit PlanCancelled(msg.sender, 0);\n    }\n\n    /**\n     * @notice Pause a SIP plan (legacy)\n     */\n    function pausePlan() external {\n        SIPPlan storage plan = legacyUserPlans[msg.sender];\n        require(plan.active, \"No active plan\");\n        \n        plan.active = false;\n        emit PlanPaused(msg.sender, 0);\n    }\n\n    /**\n     * @notice Resume a paused SIP plan (legacy)\n     */\n    function resumePlan() external {\n        SIPPlan storage plan = legacyUserPlans[msg.sender];\n        require(!plan.active, \"Plan already active\");\n        require(plan.user == msg.sender, \"No plan found\");\n        \n        plan.active = true;\n        emit PlanResumed(msg.sender, 0);\n    }\n\n    // ============================================\n    // OWNER FUNCTIONS\n    // ============================================\n\n    /**\n     * @notice Set the expert agent address for AI payments\n     */\n    function setExpertAgentAddress(address _expertAgentAddress) external onlyOwner {\n        address oldAddress = expertAgentAddress;\n        expertAgentAddress = _expertAgentAddress;\n        emit ExpertAgentAddressUpdated(oldAddress, _expertAgentAddress);\n    }\n\n    /**\n     * @notice Transfer ownership\n     */\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"Invalid address\");\n        owner = newOwner;\n    }\n\n    receive() external payable {}\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}